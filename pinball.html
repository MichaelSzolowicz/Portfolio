<!DOCTYPE html>
<html lang="eng-US">

<head>
    <title>Michael Szolowicz - Pinball Shooter</title>
    <link rel="stylesheet" href="styles/global.css">
    <script src="elements/header.js" type="text/javascript" defer></script>
    <script src="elements/footer.js" type="text/javascript" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
    <header-element></header-element>

    <main>
        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more">
                <h2>About</h2>
                <p>
                    All programming for this project was done by myself. I have used it to explore various concepts at
                    my own pace. However, given the time I would like to polish it into a publishable product. My custom
                    character controller implements physically accurate collision response and client side prediction
                    based networking. I paired that controller with context steering driven AI enemies. Also described
                    here is my input replay system, inspired by first person shooters and racing games.
                </p>
            </div>
        </div>

        <span class="spacer"></span>

        <!-- #region Character Controller -->
        <div class="section">
            <div class="subsection learn-more">
                <h2>Custom Character Controller</h2>
                <h3>Motivation</h3>
                <p>
                    My custom pinball character controller is designed to replace Unreal Engine’s built in
                    UCharacterMovementComponent. The motivation for a custom character controller was to model movement
                    after real world physics. I would like to support online multiplayer eventually, so I chose to
                    create my own solution with support for client side prediction instead of using a physics engine.
                </p>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more">
                <h3>Implementation</h3>
                <p>
                    I defined basic features in the UNetworkedPhysics component, which inherits from UMovementComponent.
                    UNetworkedPhysics is closely modeled after Unreal Engine’s UCharacterMovementComponent class. The
                    client moves locally, submits the move to the server, which evaluates the move before submitting
                    either a correction or approval.
                </p>
            </div>
        </div>

        <div class="section">
            <div class="subsection learn-more">
                <p>
                    On the client, the TickComponent() function kicks things off by calling the UpdatePhysics()
                    function, which constructs a move. Moves are represented by my own FMove struct. PerformMove() is
                    then called, taking FMinimalMove as an argument. The difference between FMove and FMinimalMove is
                    that FMove contains data needed to verify a move, while FMinimalMove only contains data needed to
                    perform a move.
                </p>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    PerformMove() integrates applied forces over the time since the last move. Before updating the
                    Actor’s position, it queries the environment for collisions. I resolve collisions in the constructor
                    logic for the FNetPhysCollisionResolution struct. The constructor takes in the
                    UNetworkedPhysicsComponents involved, hit result, and current velocity then calculates linear and
                    angular impulse which are stored in the resulting struct. The UNetworkedPhysicsComponent that
                    originally attempted the move applies these impulses to itself using the
                    ResolveCollisionWithRotation() function.
                </p>
            </div>

            <span class="spacer horizontal short"></span>

            <div class="subsection">
                <div class="codebox" style="max-height: 300px;">
                    <!-- #region Preformatted Text -->
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#4ec9b0;">FNetPhysCollisionResolution</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">FNetPhysCollisionResolution</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">UNetworkedPhysics</span><span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#4ec9b0;">UNetworkedPhysics</span><span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#4ec9b0;">FHitResult</span>&nbsp;<span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9a9a9a;">LinearVelocity</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9a9a9a;">AngularVelocity</span><span style="color:#b4b4b4;">)</span>
<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">Location</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">UpdatedComponent</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetComponentLocation</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">InverseMass</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">InverseMass</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">InverseInertia</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">InverseInertia</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">Restitution</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetRestitution</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">FrictionConstant</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Self</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetFrictionConstant</span><span style="color:#b4b4b4;">();</span>
    
    <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">RVector</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">ImpactPoint</span>&nbsp;<span style="color:#b4b4b4;">-</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">TraceStart</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Time</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">TraceEnd</span>&nbsp;<span style="color:#b4b4b4;">-</span>&nbsp;<span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">TraceStart</span><span style="color:#b4b4b4;">)));</span>
    <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">RelativeVelocity</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">LinearVelocity</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9a9a9a;">AngularVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">);</span>
    
    <span style="color:#569cd6;">bool</span>&nbsp;<span style="color:#9cdcfe;">bHasOther</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dcdcaa;">IsValid</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">SumInvMass</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">InverseMass</span><span style="color:#b4b4b4;">;</span>
    <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">MinRestitution</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">Restitution</span><span style="color:#b4b4b4;">;</span>
    
    <span style="color:#57a64a;">/*&nbsp;Normal&nbsp;Impulse&nbsp;calculation&nbsp;*/</span>
    <span style="color:#b4b4b4;">{</span>
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">NormalImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FVector</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Zero</span><span style="color:#b4b4b4;">();</span>
    
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">J1</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">InverseInertia</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">)).</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">);</span>
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">J2</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FVector</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Zero</span><span style="color:#b4b4b4;">();</span>
    
        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">bHasOther</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">OtherLinearVelocity</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetLinearVelocity</span><span style="color:#b4b4b4;">();</span>
            <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">OtherAngularVelocity</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetAngularVelocity</span><span style="color:#b4b4b4;">();</span>
            <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">OtherRVector</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetRVectorAtPoint</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">ImpactPoint</span><span style="color:#b4b4b4;">);</span>
            <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">OtherInvInertia</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">InverseInertia</span><span style="color:#b4b4b4;">();</span>
            <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">OtherInvMass</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">InverseMass</span><span style="color:#b4b4b4;">();</span>
    
            <span style="color:#9cdcfe;">J2</span>&nbsp;<span style="color:#b4b4b4;">+=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherInvInertia</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">OtherRVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">)).</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherRVector</span><span style="color:#b4b4b4;">);</span>
            <span style="color:#9cdcfe;">RelativeVelocity</span>&nbsp;<span style="color:#b4b4b4;">-=</span>&nbsp;<span style="color:#9cdcfe;">OtherLinearVelocity</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9cdcfe;">OtherAngularVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherRVector</span><span style="color:#b4b4b4;">);</span>
            <span style="color:#9cdcfe;">SumInvMass</span>&nbsp;<span style="color:#b4b4b4;">+=</span>&nbsp;<span style="color:#9cdcfe;">OtherInvMass</span><span style="color:#b4b4b4;">;</span>
            <span style="color:#9cdcfe;">MinRestitution</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FMath</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Min</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">MinRestitution</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetRestitution</span><span style="color:#b4b4b4;">());</span>
        <span style="color:#b4b4b4;">}</span>
    
        <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">SumInvMass</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">J1</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9cdcfe;">J2</span><span style="color:#b4b4b4;">).</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">);</span>
    
        <span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">RelativeVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#b4b4b4;">-(</span><span style="color:#b5cea8;">1</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9cdcfe;">MinRestitution</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">/</span>&nbsp;<span style="color:#9cdcfe;">J</span><span style="color:#b4b4b4;">;</span>
    
        <span style="color:#9cdcfe;">NormalImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">;</span>
        <span style="color:#dadada;">LinearImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">NormalImpulse</span><span style="color:#b4b4b4;">;</span>
        <span style="color:#dadada;">AngularImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">NormalImpulse</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#b4b4b4;">}</span>
    
    <span style="color:#57a64a;">/*&nbsp;Friction&nbsp;Impulse&nbsp;Calculation&nbsp;*/</span>
    <span style="color:#b4b4b4;">{</span>
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">Tangent</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">LinearVelocity</span>&nbsp;<span style="color:#b4b4b4;">-</span>&nbsp;<span style="color:#9a9a9a;">LinearVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Normal</span><span style="color:#b4b4b4;">;</span>
    
        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Size</span><span style="color:#b4b4b4;">()</span>&nbsp;<span style="color:#b4b4b4;">&lt;</span>&nbsp;<span style="color:#b5cea8;">.01f</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#d8a0df;">return</span><span style="color:#b4b4b4;">;</span>
        <span style="color:#d8a0df;">else</span>&nbsp;<span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Normalize</span><span style="color:#b4b4b4;">();</span>
    
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">J1</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">InverseInertia</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">)).</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">);</span>
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">J2</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FVector</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Zero</span><span style="color:#b4b4b4;">();</span>
    
        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">bHasOther</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">OtherRVector</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetRVectorAtPoint</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Hit</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">ImpactPoint</span><span style="color:#b4b4b4;">);</span>
            <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">OtherInvInertia</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Other</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">InverseInertia</span><span style="color:#b4b4b4;">();</span>
    
            <span style="color:#9cdcfe;">J2</span>&nbsp;<span style="color:#b4b4b4;">+=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherInvInertia</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">OtherRVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">)).</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherRVector</span><span style="color:#b4b4b4;">);</span>
        <span style="color:#b4b4b4;">}</span>
    
        <span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">SumInvMass</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">J1</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9cdcfe;">J2</span><span style="color:#b4b4b4;">).</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">);</span>
        <span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">RelativeVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Dot</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#b4b4b4;">-(</span><span style="color:#b5cea8;">1</span>&nbsp;<span style="color:#b4b4b4;">+</span>&nbsp;<span style="color:#9cdcfe;">MinRestitution</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">/</span>&nbsp;<span style="color:#9cdcfe;">J</span><span style="color:#b4b4b4;">;</span>
    
        <span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">*=</span>&nbsp;<span style="color:#9cdcfe;">FrictionConstant</span><span style="color:#b4b4b4;">;</span>
    
        <span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9cdcfe;">FrictionImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">J</span>&nbsp;<span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">Tangent</span><span style="color:#b4b4b4;">;</span>
        <span style="color:#dadada;">LinearImpulse</span>&nbsp;<span style="color:#b4b4b4;">+=</span>&nbsp;<span style="color:#9cdcfe;">FrictionImpulse</span><span style="color:#b4b4b4;">;</span>&nbsp;
        <span style="color:#dadada;">AngularImpulse</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">RVector</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Cross</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">FrictionImpulse</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#b4b4b4;">}</span>
<span style="color:#b4b4b4;">}</span></pre>
                    <!-- #endregion -->
                </div>
                <figcaption>FNetPhysCollisionResolution constructor calculates and impulse based on real world physics.</figcaption>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    An important distinguishing factor of my character controller is that it can push and be pushed by
                    other networked physics components in a physically accurate manner. If the collision query finds
                    another UNetworkedPhysics component, it will use FNetPhysCollisionResolution’s Inverse() function to
                    get the inverse collision response and apply it directly to the other UNetworkedPhysics component
                    involved in the collision.
                </p>
            </div>

            <div class="subsection">
                <div class="codebox" style="max-height: 300px;">
                    <!-- #region Preformatted Text -->
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#4ec9b0;">INetworkPhysicsInterface</span><span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">OtherInterface</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dcdcaa;">Cast</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#4ec9b0;">INetworkPhysicsInterface</span><span style="color:#b4b4b4;">&gt;(</span><span style="color:#9cdcfe;">TestHit</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">GetActor</span><span style="color:#b4b4b4;">());</span>
<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">OtherInterface</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">FNetPhysCollisionResolution</span>&nbsp;<span style="color:#9cdcfe;">ResolveOurCollision</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FNetPhysCollisionResolution</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">this</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#9cdcfe;">OtherInterface</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetNetworkPhysics</span><span style="color:#b4b4b4;">(),</span>&nbsp;<span style="color:#9cdcfe;">TestHit</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#dadada;">LinearVelocity</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#dadada;">AngularVelocity</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#4ec9b0;">FNetPhysCollisionResolution</span>&nbsp;<span style="color:#9cdcfe;">ResolveOtherCollision</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FNetPhysCollisionResolution</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Inverse</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">ResolveOurCollision</span><span style="color:#b4b4b4;">);</span>
    
    <span style="color:#9cdcfe;">OtherInterface</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetNetworkPhysics</span><span style="color:#b4b4b4;">()-&gt;</span><span style="color:#dcdcaa;">ResolveCollisionWithRotation</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">ResolveOtherCollision</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#dcdcaa;">ResolveCollisionWithRotation</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">ResolveOurCollision</span><span style="color:#b4b4b4;">);</span>
<span style="color:#b4b4b4;">}</span>
<span style="color:#d8a0df;">else</span>&nbsp;<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">FNetPhysCollisionResolution</span>&nbsp;<span style="color:#9cdcfe;">ResolveOurCollision</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FNetPhysCollisionResolution</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">this</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#569cd6;">nullptr</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#9cdcfe;">TestHit</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#dadada;">LinearVelocity</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#dadada;">AngularVelocity</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#dcdcaa;">ResolveCollisionWithRotation</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">ResolveOurCollision</span><span style="color:#b4b4b4;">);</span>
<span style="color:#b4b4b4;">}</span>
    
<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">bUseAngularMovement</span>&nbsp;<span style="color:#b4b4b4;">&amp;&amp;</span>&nbsp;<span style="color:#dcdcaa;">IsValid</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">AngularBody</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">FRotator</span>&nbsp;<span style="color:#9cdcfe;">Rot</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">UKismetMathLibrary</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">RotatorFromAxisAndAngle</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">AngularVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">GetSafeNormal</span><span style="color:#b4b4b4;">(),</span>&nbsp;<span style="color:#dadada;">AngularVelocity</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Size</span><span style="color:#b4b4b4;">());</span>
    <span style="color:#dadada;">AngularBody</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">AddWorldRotation</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Rot</span><span style="color:#b4b4b4;">);</span>
<span style="color:#b4b4b4;">}</span></pre>
                    <!-- #endregion -->
                </div>
                <figcaption>How the PerformMove() function resolves a collision.</figcaption>
            </div>
        </div>

        <div class="section">
            <div class="subsection learn-more">
                <p>
                    After resolving collisions, PerformMove() physically updates the controlled component’s location.
                </p>
            </div>
        </div>

        <div class="section">
            <div class="subsection learn-more">
                <p>
                    After the move is performed locally, the client stores its final position in the FMove struct and
                    submits it to the server. Server side PerformMove() is called again, and the final position is
                    checked against the final position submitted by the client. If they are within a very small
                    threshold the move is approved, otherwise the server sends a correction back to the client.
                </p>
            </div>
        </div>

        <div class="section">
            <div class="subsection learn-more">
                <p>
                    When the client receives a correction, it removes every move prior to the correction in
                    MovesPendingValidation. It then sets its position and velocity to the correction, and re-simulates
                    the remaining moves in MovesPendingValidation.
                </p>
            </div>
        </div>

        <div class="section">
            <div class="subsection">
                <div class="codebox">
                    <!-- #region Preformatted Text -->
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#569cd6;">void</span>&nbsp;<span style="color:#4ec9b0;">UNetworkedPhysics</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">ClientCorrection_Implementation</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9a9a9a;">EndPosition</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#4ec9b0;">FVector</span>&nbsp;<span style="color:#9a9a9a;">EndVelocity</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9a9a9a;">Time</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
    <span style="color:#dadada;">UpdatedComponent</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">SetWorldLocation</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">EndPosition</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#dadada;">LinearVelocity</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">EndVelocity</span><span style="color:#b4b4b4;">;</span>
    
    <span style="color:#57a64a;">//&nbsp;prolly&nbsp;can&nbsp;change&nbsp;this&nbsp;to&nbsp;a&nbsp;call&nbsp;to&nbsp;clientapprovemove.</span>
    <span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">Num</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Num</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#d8a0df;">for</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">&lt;</span>&nbsp;<span style="color:#9cdcfe;">Num</span><span style="color:#b4b4b4;">;</span>&nbsp;<span style="color:#9cdcfe;">i</span><span style="color:#b4b4b4;">++)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
        <span style="color:#57a64a;">//&nbsp;Remove&nbsp;all&nbsp;moves&nbsp;prior&nbsp;to&nbsp;the&nbsp;corrected&nbsp;move.</span>
        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">[</span><span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Time</span>&nbsp;<span style="color:#b4b4b4;">&lt;=</span>&nbsp;<span style="color:#9a9a9a;">Time</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">RemoveAt</span><span style="color:#b4b4b4;">(</span><span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">);</span>&nbsp;
        <span style="color:#b4b4b4;">}</span>
        <span style="color:#d8a0df;">else</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#dadada;">PrevTimestamp</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">[</span><span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Time</span><span style="color:#b4b4b4;">;</span>
            <span style="color:#d8a0df;">break</span><span style="color:#b4b4b4;">;</span>
        <span style="color:#b4b4b4;">}</span>
    <span style="color:#b4b4b4;">}</span>
    
    <span style="color:#d8a0df;">for</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">&lt;</span>&nbsp;<span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Num</span><span style="color:#b4b4b4;">();</span>&nbsp;<span style="color:#9cdcfe;">i</span><span style="color:#b4b4b4;">++)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
        <span style="color:#57a64a;">//&nbsp;Execute&nbsp;the&nbsp;remaining&nbsp;moves&nbsp;in&nbsp;moves&nbsp;pending&nbsp;validation.</span>
        <span style="color:#dcdcaa;">PerformMove</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">MovesBuffer</span><span style="color:#b4b4b4;">[</span><span style="color:#9cdcfe;">i</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">);</span>
    <span style="color:#b4b4b4;">}</span>
    <span style="color:#57a64a;">//&nbsp;Reset&nbsp;the&nbsp;prev&nbsp;timestamp.</span>
    <span style="color:#dadada;">PrevTimestamp</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dcdcaa;">GetWorld</span><span style="color:#b4b4b4;">()-&gt;</span><span style="color:#dadada;">TimeSeconds</span><span style="color:#b4b4b4;">;</span>
    
    <span style="color:#4ec9b0;">FMove</span>&nbsp;<span style="color:#9cdcfe;">Move</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#4ec9b0;">FMove</span><span style="color:#b4b4b4;">();</span>
    <span style="color:#9cdcfe;">Move</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">EndPosition</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">EndPosition</span><span style="color:#b4b4b4;">;</span>
    <span style="color:#9cdcfe;">Move</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Time</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Time</span><span style="color:#b4b4b4;">;</span>
    <span style="color:#dadada;">LastValidatedMove</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">Move</span><span style="color:#b4b4b4;">;</span>
<span style="color:#b4b4b4;">}</span></pre>
                    <!-- #endregion -->
                </div>
                <figcaption>Client correction logic.</figcaption>
            </div>
        </div>
        <!-- #endregion -->

        <span class="spacer"></span>

        <!-- #region Input Replay System -->
        <div class="section">
            <div class="subsection">
                <h2>Input Replay System</h2>
                <h3>Motivation</h3>
                <p>
                    The Ghost Replay system is designed to capture input, dispatch input back to actors, and serialize
                    captured input for later use.
                </p>
                <p>
                    One application of the Ghost Replay system is checking the stability of the physics integrator
                    across different frame rates. The lossy nature of integration can cause imbalance, namely the ball
                    being able to roll uphill at lower framerates but not higher framerates. The system should be able
                    to capture and replay directional input so developers can check if the integrator is producing
                    reasonably similar results at different frame rates. The integration will never be exact because of
                    the varying timestep, but it should be close enough as to not create imbalances like the one
                    described above.
                </p>
                <p>
                    Future applications include kill cams or “play of the game” style match highlights. These features
                    are not yet fully supported, but the ghost replay system is designed to be flexible enough to
                    accommodate production ready features of similar ilk.
                </p>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection">
                <h3>Implementation</h3>
            </div>
        </div>

        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    The backbone of this implementation is the UGhostRecorderLevelSubsystem. On initialization this
                    subsystem will use UGhostReplayConsoleParser’s static function to check for console commands to
                    record or replay input. If the console is set to replay, it will load an input replay file using
                    StartReplay() before initialization is complete. Otherwise the StartRecording() and StartReplay()
                    functions can be used to set its behavior after initialization.
                </p>
            </div>

            <span class="spacer short horizontal"></span>

            <div class="subsection">
                <div class="codebox">
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#569cd6;">void</span>&nbsp;<span style="color:#4ec9b0;">UGhostRecorderWorldSubsystem</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Initialize</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">FSubsystemCollectionBase</span><span style="color:#b4b4b4;">&amp;</span>&nbsp;<span style="color:#9a9a9a;">Collection</span><span style="color:#b4b4b4;">)</span>
<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">Super</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Initialize</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">Collection</span><span style="color:#b4b4b4;">);</span>

    <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">UGhostReplayConsoleParser</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">GetGhostReplayBehavior</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehavior</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">{</span>
        <span style="color:#dadada;">bHasConsoleCommand</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#569cd6;">true</span><span style="color:#b4b4b4;">;</span>

        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehavior</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#4ec9b0;">EGhostReplayBehavior</span><span style="color:#b4b4b4;">::</span><span style="color:#b8d7a3;">Record</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#dcdcaa;">StartRecording</span><span style="color:#b4b4b4;">();</span>
        <span style="color:#b4b4b4;">}</span>
        <span style="color:#d8a0df;">else</span>&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehavior</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#4ec9b0;">EGhostReplayBehavior</span><span style="color:#b4b4b4;">::</span><span style="color:#b8d7a3;">Replay</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#dcdcaa;">StartReplay</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">UGhostReplayConsoleParser</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">GetDefaultReplayFilePath</span><span style="color:#b4b4b4;">());</span>
        <span style="color:#b4b4b4;">}</span>

        <span style="color:#beb7ff;">UE_LOG</span><span style="color:#b4b4b4;">(</span><span style="color:#c8c8c8;">GhostRecorderWorldSubsystem</span><span style="color:#b4b4b4;">,</span>&nbsp;Log<span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#beb7ff;">TEXT</span><span style="color:#b4b4b4;">(</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#d69d85;">Ghost&nbsp;Data&nbsp;Behavior:&nbsp;%s</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#b4b4b4;">),</span>&nbsp;<span style="color:#b4b4b4;">*</span><span style="color:#4ec9b0;">UEnum</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">GetValueAsString</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehavior</span><span style="color:#b4b4b4;">));</span>
        <span style="color:#beb7ff;">UE_LOG</span><span style="color:#b4b4b4;">(</span><span style="color:#c8c8c8;">GhostRecorderWorldSubsystem</span><span style="color:#b4b4b4;">,</span>&nbsp;Log<span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#beb7ff;">TEXT</span><span style="color:#b4b4b4;">(</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#d69d85;">Ghost&nbsp;Replay&nbsp;File:&nbsp;%s</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#b4b4b4;">),</span>&nbsp;<span style="color:#b4b4b4;">*</span><span style="color:#4ec9b0;">UGhostReplayConsoleParser</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">GetDefaultReplayFilePath</span><span style="color:#b4b4b4;">());</span>
    <span style="color:#b4b4b4;">}</span>
<span style="color:#b4b4b4;">}</span></pre>
                </div>
                <figcaption>Ghost Record Level Subsystem Initialize function.</figcaption>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    To record input, Actors must manually access UGhostRecorderLevelSubsystem and call the GetNextInputCaptureSlot()
                    function. GetNextInputCaptureSlot() returns a pointer to a FGhostReplayInput struct so that captured input can
                    be copied
                    directly into its final destination, rather than being passed to the function first. The actor ID, name of the
                    input,
                    and value of the input should be copied to the FGhostReplayInput struct.
                </p>
            </div>

            <span class="spacer short horizontal"></span>

            <div class="subsection">
                <div class="codebox">
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#57a64a;">/**</span>
<span style="color:#57a64a;">*&nbsp;Apply&nbsp;force&nbsp;directly&nbsp;to&nbsp;player&nbsp;via&nbsp;network&nbsp;physics&nbsp;component.</span>
<span style="color:#57a64a;">*/</span>
<span style="color:#569cd6;">void</span>&nbsp;<span style="color:#4ec9b0;">APinballPlayer</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Push</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">const</span>&nbsp;<span style="color:#4ec9b0;">FInputActionValue</span><span style="color:#b4b4b4;">&amp;</span>&nbsp;<span style="color:#9a9a9a;">Value</span><span style="color:#b4b4b4;">)</span>
<span style="color:#b4b4b4;">{</span>
    <span style="color:#4ec9b0;">FVector2D</span>&nbsp;<span style="color:#9cdcfe;">Input</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9a9a9a;">Value</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Get</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#4ec9b0;">FVector2D</span><span style="color:#b4b4b4;">&gt;();</span>
    <span style="color:#57a64a;">//UE_LOG(LogTemp,&nbsp;Warning,&nbsp;TEXT(&quot;Input&nbsp;push:&nbsp;%s&quot;),&nbsp;*Input.ToString());</span>
    
    <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehvaior</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#4ec9b0;">EGhostReplayBehavior</span><span style="color:#b4b4b4;">::</span><span style="color:#b8d7a3;">RecordPush</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
        <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dcdcaa;">IsValid</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostRecorder</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">{</span>
            <span style="color:#4ec9b0;">FGhostReplayInput</span><span style="color:#b4b4b4;">*</span>&nbsp;<span style="color:#9cdcfe;">GhostReplayInput</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dadada;">GhostRecorder</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">GetNextInputCaptureSlot</span><span style="color:#b4b4b4;">();</span>
            <span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">GhostReplayInput</span>&nbsp;<span style="color:#b4b4b4;">!=</span>&nbsp;<span style="color:#569cd6;">nullptr</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
                <span style="color:#9cdcfe;">GhostReplayInput</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">ActorID</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dcdcaa;">GetName</span><span style="color:#b4b4b4;">();</span>
                <span style="color:#9cdcfe;">GhostReplayInput</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">ActionName</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#beb7ff;">TEXT</span><span style="color:#b4b4b4;">(</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#d69d85;">Push</span><span style="color:#e8c9bb;">&quot;</span><span style="color:#b4b4b4;">);</span>
                <span style="color:#9cdcfe;">GhostReplayInput</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">At</span><span style="color:#b4b4b4;">(</span><span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">Input</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">X</span><span style="color:#b4b4b4;">;</span>
                <span style="color:#9cdcfe;">GhostReplayInput</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">At</span><span style="color:#b4b4b4;">(</span><span style="color:#b5cea8;">1</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">Input</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Y</span><span style="color:#b4b4b4;">;</span>
            <span style="color:#b4b4b4;">}</span>
        <span style="color:#b4b4b4;">}</span>
    <span style="color:#b4b4b4;">}</span>
    
    <span style="color:#dadada;">NetworkPhysics</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dcdcaa;">SetInput</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">Input</span><span style="color:#b4b4b4;">);</span>
<span style="color:#b4b4b4;">}</span></pre>
                </div>
                <figcaption>Pinball pawn saving an input via the ghost recorder.</figcaption>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    To replay input, actors should use the UGhostReplayController component for convenience sake. Create the controller
                    component, then use the GetGhostInputActionReference() function to bind functions to named inputs. The input name
                    provided to GetGhostInputActionReference() should be the same name used when recording the corresponding input.
                </p>
            </div>
        
            <span class="spacer short horizontal"></span>
        
            <div class="subsection">
                <div class="codebox">
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#4ec9b0;">FGhostInputAction</span><span style="color:#b4b4b4;">&amp;</span>&nbsp;<span style="color:#4ec9b0;">UGhostController</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">GetGhostInputActionReference</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">FString</span>&nbsp;<span style="color:#9a9a9a;">ActionName</span><span style="color:#b4b4b4;">)</span>
<span style="color:#b4b4b4;">{</span>
	<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(!</span><span style="color:#dadada;">GhostInputActions</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Contains</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">ActionName</span><span style="color:#b4b4b4;">))</span>&nbsp;<span style="color:#b4b4b4;">{</span>
		<span style="color:#dadada;">GhostInputActions</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Add</span><span style="color:#b4b4b4;">(</span><span style="color:#9a9a9a;">ActionName</span><span style="color:#b4b4b4;">);</span>
	<span style="color:#b4b4b4;">}</span>
 
	<span style="color:#d8a0df;">return</span>&nbsp;<span style="color:#dadada;">GhostInputActions</span><span style="color:#b4b4b4;">[</span><span style="color:#9a9a9a;">ActionName</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">;</span>
<span style="color:#b4b4b4;">}</span></pre>
                </div>
                <figcaption>Pinball pawn saving an input via the ghost recorder.</figcaption>
            </div>
        </div>

        <span class="spacer"></span>
        
        <div class="section">
            <div class="subsection learn-more thin">
                <p>
                    Lastly, if UGhostRecorderLevelSubsystem is set to replay, the Tick function will go through captured input in order and
                    broadcast it via the delegate. UGhostReplayController components are already set up to listen for this delegate. Using
                    GetGhostInputActionReference() you can add further delegates to the map. UGhostReplayController will then check if
                    dispatched input is for its owning actor, and if the captured input name corresponds to a delegate in its map, before
                    calling that delegate.
                </p>
            </div>
        
            <span class="spacer short horizontal"></span>
        
            <div class="subsection">
                <div class="codebox">
<pre style="font-family:Cascadia Mono;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#569cd6;">void</span>&nbsp;<span style="color:#4ec9b0;">UGhostRecorderWorldSubsystem</span><span style="color:#b4b4b4;">::</span><span style="color:#dcdcaa;">Tick</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">float</span>&nbsp;<span style="color:#9a9a9a;">DeltaTime</span><span style="color:#b4b4b4;">)</span>
<span style="color:#b4b4b4;">{</span>
	<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">GhostReplayBehavior</span>&nbsp;<span style="color:#b4b4b4;">!=</span>&nbsp;<span style="color:#4ec9b0;">EGhostReplayBehavior</span><span style="color:#b4b4b4;">::</span><span style="color:#b8d7a3;">Replay</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
		<span style="color:#d8a0df;">return</span><span style="color:#b4b4b4;">;</span>
	<span style="color:#b4b4b4;">}</span>
 
	<span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">ElapsedTimeSeconds</span>&nbsp;<span style="color:#b4b4b4;">+=</span>&nbsp;<span style="color:#9a9a9a;">DeltaTime</span><span style="color:#b4b4b4;">;</span>
 
	<span style="color:#d8a0df;">while</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">NextIndex</span>&nbsp;<span style="color:#b4b4b4;">&lt;</span>&nbsp;<span style="color:#dadada;">GhostReplayData</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">TimestampsCount</span>&nbsp;<span style="color:#b4b4b4;">&amp;&amp;</span>&nbsp;
		<span style="color:#dadada;">GhostReplayData</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">CapturedData</span><span style="color:#b4b4b4;">[</span><span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">NextIndex</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">Timestamp</span>&nbsp;<span style="color:#b4b4b4;">&lt;=</span>&nbsp;<span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">ElapsedTimeSeconds</span><span style="color:#b4b4b4;">)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
 
		<span style="color:#4ec9b0;">FGhostReplayTimestamp</span>&nbsp;<span style="color:#9cdcfe;">GhostReplayTimestamp</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dadada;">GhostReplayData</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">CapturedData</span><span style="color:#b4b4b4;">[</span><span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">NextIndex</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">;</span>
		<span style="color:#dadada;">ReplayParameters</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">NextIndex</span><span style="color:#b4b4b4;">++;</span>
		
		<span style="color:#d8a0df;">for</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">CapturedInputIndex</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>&nbsp;<span style="color:#9cdcfe;">CapturedInputIndex</span>&nbsp;<span style="color:#b4b4b4;">&lt;</span>&nbsp;<span style="color:#9cdcfe;">GhostReplayTimestamp</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">CapturedInputCount</span><span style="color:#b4b4b4;">;</span>&nbsp;<span style="color:#9cdcfe;">CapturedInputIndex</span><span style="color:#b4b4b4;">++)</span>&nbsp;<span style="color:#b4b4b4;">{</span>
			<span style="color:#4ec9b0;">FGhostReplayInput</span>&nbsp;<span style="color:#9cdcfe;">CapturedInput</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">GhostReplayTimestamp</span><span style="color:#b4b4b4;">.</span><span style="color:#dadada;">CapturedInput</span><span style="color:#b4b4b4;">[</span><span style="color:#9cdcfe;">CapturedInputIndex</span><span style="color:#b4b4b4;">]</span><span style="color:#b4b4b4;">;</span>
 
			<span style="color:#dadada;">ReplayInputDispatcher</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">Broadcast</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">CapturedInput</span><span style="color:#b4b4b4;">);</span>
		<span style="color:#b4b4b4;">}</span>
	<span style="color:#b4b4b4;">}</span>
<span style="color:#b4b4b4;">}</span></pre>
                </div>
                <figcaption>Pinball pawn saving an input via the ghost recorder.</figcaption>
            </div>
        </div>

        <span class="spacer"></span>

        <div class="section">
            <div class="subsection learn-more">
                <h3>Limitations</h3>
                <p>
                    A maximum of 5 floats can be used to capture input data. This number is defined in the GHOST_REPLAY_INPUT_SIZE macro.
                    Limiting captured input to a fixed type and size makes it easier to allocate space for, serialize, and deserialize input
                    data. The drawback is that the actors saving or receiving replay data must convert data to and from the proper format. I
                    decided this was acceptable because (a) there will be a limited number of actors which actually need to save input in
                    this game and (b) the work required to save a replay input on the actor side is not very time consuming, even though it
                    is not ideal for maintainability.
                </p>
                <p>
                    UGhostRecorderLevelSubsytem is implemented as a level system, meaning it will lose recorded data when a new level is
                    loaded unless the data is serialized first. In the future this behavior might be altered by changing it to a game
                    subsystem, but this might interfere with the use of Tick to dispatch replay data. In this case a separate actor or
                    subsystem may be created for the explicit purpose of replaying input.
                </p>
            </div>
        </div>

        <span class="spacer"></span>
                
        <div class="section">
            <div class="subsection learn-more">
                <h3>Future Work</h3>
                <p>
                    Right now UGhostRecorderLevelSubsystem will always allocate more memory if it runs out of slots to store new input in.
                    In order to ship this project, the system should use a fixed memory footprint and wrap around, deleting old data in the
                    process, if it runs out of space.
                </p>
                <p>
                    In order to implement highlights without replaying input from the start of the match onwards, the starting state of each
                    recorded actor will need to be saved as well. It would be inefficient to do this every frame, so a separate system will
                    probably be created to capture this data every ½ or even full second.
                </p>
                <p>
                    To fully support match highlights, a new controller will need to be created for this explicit purpose. It will need to
                    weigh what parts of the match are most interesting, and manipulate UGhostRecorderLevelSubsystem to not overwrite data it
                    has deemed a “highlight.”
                </p>
            </div>
        </div>
        <!-- #endregion -->

        <span class="spacer"></span>
    </main>

    <footer-element></footer-element>
</body>

</html>